在工厂方法模式中，我们使用一个工厂创建一个产品，也就是说一个具体的工厂对应一个具体的产品。
但是有时候我们需要一个工厂能够提供多个产品对象，而不是单一的对象，这个时候我们就需要使用抽象工厂模式。

在讲解抽象工厂模式之前，我们需要理清两个概念：

    1、产品等级结构。产品的等级结构也就是产品的继承结构。
       例如一个为空调的抽象类，它有海尔空调、格力空调、美的空调等一系列的子类，那么这个抽象类空调和他的子类就构成了一个产品等级结构。
    2、产品族。产品族是在抽象工厂模式中的。
       在抽象工厂模式中，产品族是指由同一个工厂生产的，位于不同产品等级结构中的一组产品。比如，海尔工厂生产海尔空调。海尔冰箱，那么海尔空调则位于空调产品族中。

一、基本定义

抽象工厂模式提供一个接口，用于创建相关或者依赖对象的家族，而不需要明确指定具体类。

抽象工厂允许客户端使用抽象的接口来创建一组相关的产品，而不需要关系实际产出的具体产品是什么。这样一来，客户就可以从具体的产品中被解耦。

二、模式结构
    模式结构说明：
    AbstractFactory：抽象工厂。抽象工厂定义了一个接口，所有的具体工厂都必须实现此接口，这个接口包含了一组方法用来生产产品。
    ConcreteFactory：具体工厂。具体工厂是用于生产不同产品族。要创建一个产品，客户只需要使用其中一个工厂完全不需要实例化任何产品对象。
    AbstractProduct：抽象产品。这是一个产品家族，每一个具体工厂都能够生产一整组产品。
    Product：具体产品。

三、模式实现
举例：为了要保证每家加盟店都能够生产高质量的披萨，防止使用劣质的原料，我们打算建造一家生产原料的工厂，并将原料运送到各家加盟店。
但是加盟店都位于不同的区域，比如纽约、芝加哥。纽约使用一组原料，芝加哥使用另一种原料。
在这里我们可以这样理解，这些不同的区域组成了原料家族，每个区域实现了一个完整的原料家族。

1、首先创建一个原料工厂。该工厂为抽象工厂，负责创建所有的原料：PizzaIngredientFactory.java
2、原料工厂创建完成之后，需要创建具体的原料工厂。该具体工厂只需要继承PizzaIngredientFactory，然后实现里面的方法即可。
    纽约原料工厂：NYPizzaIngredientFactory.java。
3、重新返回到披萨。在这个披萨类里面，我们需要使用原料，其他方法保持不变，将prepare()方法声明为抽象，
    在这个方法中，我们需要收集披萨所需要的原料。Pizza.java
    Pizza的代码利用相关的工厂生产原料。所生产的原料依赖所使用的工厂，
    Pizza类根本不关心这些原料，它只需要知道如何制作披萨即可。这里，Pizza和区域原料之间被解耦。

四、模式优缺点
    优点
      1、抽象工厂隔离了具体类的生成，客户端不需要知道什么被创建。所有的具体工厂都实现了抽象工厂中定义的公共接口，
           因此只需要改变具体工厂的实例，就可以在某种程度上改变整个软件系统的行为。
      2、当一个产品族中的多个对象被设计成一起工作时，它能够保证客户端始终只使用同一个产品族中的对象。
    缺点
      添加新的行为时比较麻烦。如果需要添加一个新产品族对象时，需要更改接口及其下所有子类，这必然会带来很大的麻烦

五、模式使用场景
    1. 一个系统不应当依赖于产品类实例如何被创建、组合和表达的细节，这对于所有类型的工厂模式都是重要的。
    2. 系统中有多于一个的产品族，而每次只使用其中某一产品族。
    3. 属于同一个产品族的产品将在一起使用，这一约束必须在系统的设计中体现出来。
    4. 系统提供一个产品类的库，所有的产品以同样的接口出现，从而使客户端不依赖于具体实现

六、总结
    抽象工厂模式中主要的优点在于具体类的隔离，客户端不需要知道什么被创建了。其缺点在于增加新的等级产品结构比较复杂，需要修改接口及其所有子类。














